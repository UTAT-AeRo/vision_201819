# Sample Call
#
# p = MetadataProcessor()
# r = c.Read("test/2018-05-25_16-22-29-018.txt")
# p.Process(r)
#
# p = MetadataProcessor()
# r = c.ReadFromImageFilePath("test/2018-05-25_16-22-29-018.bmp")
# p.Process(r)


# Sample Output
#
# {
#   "corrected": {
#     "gps": {
#       "longitude": "-79.471321",
#       "latitude": "43.750072",
#       "altitude_agl": "57.169998",
#       "timestamp": "2018-05-25_16-22-28-918"
#     },
#     "altitude": {
#       "roll_angle": "-9.738050",
#       "pitch_angle": "-2.027207",
#       "yaw_angle": "-52.516975",
#       "timestamp": "2018-05-25_16-22-28-197"
#     },
#     "timestamp": "307819"
#   },
#   "uncorrected": {
#     "gps": {
#       "longitude": "-79.471306",
#       "latitude": "43.750061",
#       "altitude_agl": "56.959999",
#       "timestamp": "2018-05-25_16-22-28-918"
#     },
#     "altitude": {
#       "roll_angle": "-7.079698",
#       "pitch_angle": "-1.237615",
#       "yaw_angle": "-51.876190",
#       "timestamp": "2018-05-25_16-22-28-197"
#     },
#     "timestamp": "307599"
#   },
#   "index": "0"
# }
#
# The corrected data should be used over the uncorrected data, but is left in for debugging reasons.
#
# If the index is 0, the data is extrapolated, else data is inteprolated with number being the index within the queue
# See https://github.com/UTAT-AeRo/TeledyneDalsa_Odroid/issues/2
#
# Throw exceptions on reading error


class MetadataProcessor(object):
    """Processor for the metadata generated by the image capture. https://github.com/UTAT-AeRo/TeledyneDalsa_Odroid"""

    def Read(self, path):
        """Returns a string of text from the given file path

        Keyword arguments:
        path - the relative path to the file
        """

        try:
            f = open(path, "r")
            if f.mode != 'r':
                raise ValueError('the given reader is not in reading mode')

            # Read in the file and perform basic validation
            return f.read()
        except EnvironmentError:
            raise ValueError('the metadata file was not found/could be read')

    def ReadFromImageFilePath(self, path):
        """Returns a string of text from the given file path provided the file is the image file

        Keyword arguments:
        path - the relative path to the file
        """

        newPath = path[:path.rfind(".")] + ".txt"
        return self.Read(newPath)

    def Process(self, text):
        """Returns an object representation of the metadata file

        Keyword arguments:
        text - the text of the metadata
        """

        c_split = text.split("\n")
        if len(c_split) != 8:
            raise ValueError('provided metadata file has incorrect number of lines')

        # Corrected GPS data
        data = c_split[0].split(",")
        if len(data) != 4:
            raise ValueError('corrected gps length mismatch')
        corr_gps = {"longitude": data[0], "latitude": data[1], "altitude_agl": data[2], "timestamp": data[3]}

        # Corrected altitude data
        data = c_split[1].split(",")
        if len(data) != 4:
            raise ValueError('corrected altitude length mismatch')
        corr_alt = {"roll_angle": data[0], "pitch_angle": data[1], "yaw_angle": data[2], "timestamp": data[3]}

        # Corrected timestamp ms
        corr_ts = c_split[2]

        # Index
        index = c_split[3]

        # UnCorrected GPS data
        data = c_split[4].split(",")
        if len(data) != 4:
            raise ValueError('corrected gps length mismatch')
        uncorr_gps = {"longitude": data[0], "latitude": data[1], "altitude_agl": data[2], "timestamp": data[3]}

        # UnCorrected altitude data
        data = c_split[5].split(",")
        if len(data) != 4:
            raise ValueError('corrected altitude length mismatch')
        uncorr_alt = {"roll_angle": data[0], "pitch_angle": data[1], "yaw_angle": data[2], "timestamp": data[3]}

        # UnCorrected timestamp ms
        uncorr_ts = c_split[6]

        # Final
        return {
            "corrected": {"gps": corr_gps, "altitude": corr_alt, "timestamp": corr_ts},
            "uncorrected": {"gps": uncorr_gps, "altitude": uncorr_alt, "timestamp": uncorr_ts},
            "index": index
        }
